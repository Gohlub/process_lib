//! Uqbar process standard library for Rust compiled to WASM
//! Must be used in context of bindings generated by `uqbar.wit`.
//!
//! This library provides a set of functions for interacting with the Uqbar
//! kernel interface, which is a WIT file. The types generated by this file
//! are available in processes via the wit_bindgen macro, if a process needs
//! to use them directly. However, the most convenient way to do most things
//! will be via this library.
pub use crate::uqbar::process::standard::*;
use serde::{Deserialize, Serialize};
use std::hash::{Hash, Hasher};

wit_bindgen::generate!({
    path: "wit",
    world: "lib",
});

/// Interact with the HTTP server and client modules.
/// Contains types from the `http` crate to use as well.
pub mod http;
/// The types that the kernel itself uses -- warning -- these will
/// be incompatible with WIT types in some cases, leading to annoying errors.
/// Use only to interact with the kernel or runtime in certain ways.
pub mod kernel_types;
/// Interact with the timer runtime module.
pub mod timer;
/// Interact with the Uqbar Filesystem. Usually you will not have the
/// capability to do so! Use the VFS or a database app instead.
pub mod filesystem;

/// Override the println! macro to print to the terminal. Uses the
/// `print_to_terminal` function from the WIT interface on maximally-verbose
/// mode, i.e., this print will always show up in the terminal. To control
/// the verbosity, use the `print_to_terminal` function directly.
#[macro_export]
macro_rules! println {
    () => {
        $crate::print_to_terminal(0, "\n");
    };
    ($($arg:tt)*) => {{
        $crate::print_to_terminal(0, &format!($($arg)*));
    }};
}

/// PackageId is like a ProcessId, but for a package. Only contains the name
/// of the package and the name of the publisher.
#[derive(Hash, Eq, PartialEq, Debug, Clone, Serialize, Deserialize)]
pub struct PackageId {
    package_name: String,
    publisher_node: String,
}

impl PackageId {
    /// Create a new `PackageId`.
    pub fn new(package_name: &str, publisher_node: &str) -> Self {
        PackageId {
            package_name: package_name.into(),
            publisher_node: publisher_node.into(),
        }
    }
    /// Attempt to parse a `PackageId` from a string. The string must
    /// contain exactly two segments, where segments are strings separated
    /// by a colon `:`. The segments cannot themselves contain colons.
    /// Please note that while any string without colons will parse successfully
    /// to create a `PackageId`, not all strings without colons are actually
    /// valid usernames, which the `publisher_node` field of a `PackageId` will
    /// always in practice be.
    pub fn from_str(input: &str) -> Result<Self, ProcessIdParseError> {
        // split string on colons into 2 segments
        let mut segments = input.split(':');
        let package_name = segments
            .next()
            .ok_or(ProcessIdParseError::MissingField)?
            .to_string();
        let publisher_node = segments
            .next()
            .ok_or(ProcessIdParseError::MissingField)?
            .to_string();
        if segments.next().is_some() {
            return Err(ProcessIdParseError::TooManyColons);
        }
        Ok(PackageId {
            package_name,
            publisher_node,
        })
    }
    /// Read the package name from a `PackageId`.
    pub fn package(&self) -> &str {
        &self.package_name
    }
    /// Read the publisher node ID from a `PackageId`. Note that `PackageId`
    /// segments are not parsed for validity, and a node ID stored here is
    /// not guaranteed to be a valid ID in the Uqbar name system, or be connected
    /// to an Uqbar identity at all.
    pub fn publisher(&self) -> &str {
        &self.publisher_node
    }
}

impl std::fmt::Display for PackageId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}:{}", self.package_name, self.publisher_node)
    }
}

/// `ProcessId` is defined in the wit bindings, but constructors and methods
/// are defined here. A `ProcessId` contains a process name, a package name,
/// and a publisher node ID.
impl ProcessId {
    /// Create a new `ProcessId`. If `process_name` is left as None, this will generate
    /// a random u64 number, convert to string, and store that as the name.
    pub fn new(process_name: Option<&str>, package_name: &str, publisher_node: &str) -> Self {
        ProcessId {
            process_name: process_name
                .unwrap_or(&rand::random::<u64>().to_string())
                .into(),
            package_name: package_name.into(),
            publisher_node: publisher_node.into(),
        }
    }
    /// Attempts to parse a `ProcessId` from a string. To succeed, the string must contain
    /// exactly 3 segments, separated by colons `:`. The segments must not contain colons.
    /// Please note that while any string without colons will parse successfully
    /// to create a `ProcessId`, not all strings without colons are actually
    /// valid usernames, which the `publisher_node` field of a `ProcessId` will
    /// always in practice be.
    pub fn from_str(input: &str) -> Result<Self, ProcessIdParseError> {
        // split string on colons into 3 segments
        let mut segments = input.split(':');
        let process_name = segments
            .next()
            .ok_or(ProcessIdParseError::MissingField)?
            .to_string();
        let package_name = segments
            .next()
            .ok_or(ProcessIdParseError::MissingField)?
            .to_string();
        let publisher_node = segments
            .next()
            .ok_or(ProcessIdParseError::MissingField)?
            .to_string();
        if segments.next().is_some() {
            return Err(ProcessIdParseError::TooManyColons);
        }
        Ok(ProcessId {
            process_name,
            package_name,
            publisher_node,
        })
    }
    /// Read the process name from a `ProcessId`.
    pub fn process(&self) -> &str {
        &self.process_name
    }
    /// Read the package name from a `ProcessId`.
    pub fn package(&self) -> &str {
        &self.package_name
    }
    /// Read the publisher node ID from a `ProcessId`. Note that `ProcessId`
    /// segments are not parsed for validity, and a node ID stored here is
    /// not guaranteed to be a valid ID in the Uqbar name system, or be connected
    /// to an Uqbar identity at all.
    pub fn publisher(&self) -> &str {
        &self.publisher_node
    }
}

impl Serialize for ProcessId {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        format!("{}", self).serialize(serializer)
    }
}

impl<'a> Deserialize<'a> for ProcessId {
    fn deserialize<D>(deserializer: D) -> Result<ProcessId, D::Error>
    where
        D: serde::de::Deserializer<'a>,
    {
        let s = String::deserialize(deserializer)?;
        ProcessId::from_str(&s).map_err(serde::de::Error::custom)
    }
}

impl Hash for ProcessId {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.process_name.hash(state);
        self.package_name.hash(state);
        self.publisher_node.hash(state);
    }
}

impl Eq for ProcessId {}

impl From<(&str, &str, &str)> for ProcessId {
    fn from(input: (&str, &str, &str)) -> Self {
        ProcessId::new(Some(input.0), input.1, input.2)
    }
}

impl std::fmt::Display for ProcessId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}:{}:{}",
            self.process_name, self.package_name, self.publisher_node
        )
    }
}

impl PartialEq for ProcessId {
    fn eq(&self, other: &Self) -> bool {
        self.process_name == other.process_name
            && self.package_name == other.package_name
            && self.publisher_node == other.publisher_node
    }
}

impl PartialEq<&str> for ProcessId {
    fn eq(&self, other: &&str) -> bool {
        &self.to_string() == other
    }
}

impl PartialEq<ProcessId> for &str {
    fn eq(&self, other: &ProcessId) -> bool {
        self == &other.to_string()
    }
}

#[derive(Debug)]
pub enum ProcessIdParseError {
    TooManyColons,
    MissingField,
}

impl std::fmt::Display for ProcessIdParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                ProcessIdParseError::TooManyColons => "Too many colons in ProcessId string",
                ProcessIdParseError::MissingField => "Missing field in ProcessId string",
            }
        )
    }
}

impl std::error::Error for ProcessIdParseError {
    fn description(&self) -> &str {
        match self {
            ProcessIdParseError::TooManyColons => "Too many colons in ProcessId string",
            ProcessIdParseError::MissingField => "Missing field in ProcessId string",
        }
    }
}

/// Address is defined in the wit bindings, but constructors and methods here.
/// An `Address` is a combination of an Uqbar node ID and a [`ProcessId`]. It is
/// used in the Request/Response pattern to indicate which process on a given node
/// in the Uqbar Network to direct the message to. The formatting structure for
/// an Address is `node@process_name:package_name:publisher_node`
impl Address {
    /// Create a new `Address`. Takes a node ID and a process ID.
    pub fn new<T, U>(node: T, process: U) -> Address
    where
        T: Into<String>,
        U: Into<ProcessId>,
    {
        Address {
            node: node.into(),
            process: process.into(),
        }
    }
    /// Attempt to parse an `Address` from a string. The formatting structure for
    /// an Address is `node@process_name:package_name:publisher_node`.
    ///
    /// TODO: clarify if `@` can be present in process name / package name / publisher name
    ///
    /// TODO: ensure `:` cannot sneak into first segment
    pub fn from_str(input: &str) -> Result<Self, AddressParseError> {
        // split string on colons into 4 segments,
        // first one with @, next 3 with :
        let mut name_rest = input.split('@');
        let node = name_rest
            .next()
            .ok_or(AddressParseError::MissingField)?
            .to_string();
        let mut segments = name_rest
            .next()
            .ok_or(AddressParseError::MissingNodeId)?
            .split(':');
        let process_name = segments
            .next()
            .ok_or(AddressParseError::MissingField)?
            .to_string();
        let package_name = segments
            .next()
            .ok_or(AddressParseError::MissingField)?
            .to_string();
        let publisher_node = segments
            .next()
            .ok_or(AddressParseError::MissingField)?
            .to_string();
        if segments.next().is_some() {
            return Err(AddressParseError::TooManyColons);
        }
        Ok(Address {
            node,
            process: ProcessId {
                process_name,
                package_name,
                publisher_node,
            },
        })
    }
}

impl Serialize for Address {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        format!("{}", self).serialize(serializer)
    }
}

impl<'a> Deserialize<'a> for Address {
    fn deserialize<D>(deserializer: D) -> Result<Address, D::Error>
    where
        D: serde::de::Deserializer<'a>,
    {
        let s = String::deserialize(deserializer)?;
        Address::from_str(&s).map_err(serde::de::Error::custom)
    }
}

impl Hash for Address {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.node.hash(state);
        self.process.hash(state);
    }
}

impl Eq for Address {}

impl PartialEq for Address {
    fn eq(&self, other: &Self) -> bool {
        self.node == other.node && self.process == other.process
    }
}

impl<T, U, V, W> From<(T, U, V, W)> for Address
where
    T: Into<String>,
    U: Into<&'static str>,
    V: Into<&'static str>,
    W: Into<&'static str>,
{
    fn from(input: (T, U, V, W)) -> Self {
        Address::new(
            input.0.into(),
            (input.1.into(), input.2.into(), input.3.into()),
        )
    }
}

impl<T> From<(&str, T)> for Address
where
    T: Into<ProcessId>,
{
    fn from(input: (&str, T)) -> Self {
        Address::new(input.0, input.1)
    }
}

impl std::fmt::Display for Address {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}@{}", self.node, self.process)
    }
}

/// Error type for parsing an `Address` from a string.
#[derive(Debug)]
pub enum AddressParseError {
    TooManyColons,
    MissingNodeId,
    MissingField,
}

impl std::fmt::Display for AddressParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                AddressParseError::TooManyColons => "Too many colons in ProcessId string",
                AddressParseError::MissingNodeId => "Node ID missing",
                AddressParseError::MissingField => "Missing field in ProcessId string",
            }
        )
    }
}

impl std::error::Error for AddressParseError {
    fn description(&self) -> &str {
        match self {
            AddressParseError::TooManyColons => "Too many colons in ProcessId string",
            AddressParseError::MissingNodeId => "Node ID missing",
            AddressParseError::MissingField => "Missing field in ProcessId string",
        }
    }
}

//
// Here, we define wrappers over the wit bindings to make them easier to use.
// This library prescribes the use of IPC and metadata types serialized and
// deserialized to JSON, which is far from optimal for performance, but useful
// for applications that want to maximize composability and introspectability.
// For payloads, we use bincode to serialize and deserialize to bytes.
//

/// Request builder. Use [`RequestBuilder::new()`] to start a request, then build it,
/// then call [`RequestBuilder::send()`] on it to fire.
pub struct RequestBuilder {
    target: Option<Address>,
    inherit: bool,
    timeout: Option<u64>,
    ipc: Option<Vec<u8>>,
    metadata: Option<String>,
    payload: Option<Payload>,
    context: Option<Vec<u8>>,
}

#[allow(dead_code)]
impl RequestBuilder {
    /// Start building a new `Request`. In order to successfully send, a
    /// `Request` must have at least a `target` and an `ipc`. Calling send
    /// on this before filling out these fields will result in an error.
    pub fn new() -> Self {
        RequestBuilder {
            target: None,
            inherit: false,
            timeout: None,
            ipc: None,
            metadata: None,
            payload: None,
            context: None,
        }
    }
    /// Start building a new Request with the Address of the target. In order
    /// to successfully send, you must still fill out at least the `ipc` field
    /// by calling `ipc()` or `try_ipc()` next.
    pub fn to<T>(target: T) -> Self
    where
        T: Into<Address>,
    {
        RequestBuilder {
            target: Some(target.into()),
            inherit: false,
            timeout: None,
            ipc: None,
            metadata: None,
            payload: None,
            context: None,
        }
    }
    /// Set the target [`Address`] that this request will go to.
    pub fn target<T>(mut self, target: T) -> Self
    where
        T: Into<Address>,
    {
        self.target = Some(target.into());
        self
    }
    /// Set whether this request will "inherit" the source / context / payload
    /// of the request that this process most recently received. The purpose
    /// of inheritance, in this setting, is twofold:
    ///
    /// One, setting inherit to `true` and not attaching a `Payload` will result
    /// in the previous request's payload being attached to this request. This
    /// is useful for optimizing performance of middleware and other chains of
    /// requests that can pass large quantities of data through multiple
    /// processes without repeatedly pushing it across the WASM boundary.
    ///
    /// *Note that if the payload of this request is set separately, this flag
    /// will not override it.*
    ///
    /// Two, setting inherit to `true` and *not expecting a response* will lead
    /// to the previous request's sender receiving the potential response to
    /// *this* request. This will only happen if the previous request's sender
    /// was expecting a response. This behavior chains, such that many processes
    /// could handle inheriting requests while passing the ultimate response back
    /// to the very first requester.
    pub fn inherit(mut self, inherit: bool) -> Self {
        self.inherit = inherit;
        self
    }
    /// Set whether this request expects a response, and provide a timeout value
    /// (in seconds) within which that response must be received. The sender will
    /// receive an error message with this request stored within it if the
    /// timeout is triggered.
    pub fn expects_response(mut self, timeout: u64) -> Self {
        self.timeout = Some(timeout);
        self
    }
    /// Set the IPC (Inter-Process Communication) value for this message. This field
    /// is mandatory. An IPC is simply a vector of bytes. Process developers are
    /// responsible for architecting the serialization/derserialization strategy
    /// for these bytes, but the simplest and most common strategy is just to use
    /// a JSON spec that gets stored in bytes as a UTF-8 string.
    ///
    /// If the serialization strategy is complex, it's best to define it as an impl
    /// of [`TryInto`] on your IPC type, then use `try_ipc()` instead of this.
    pub fn ipc<T>(mut self, ipc: T) -> Self
    where
        T: Into<Vec<u8>>,
    {
        self.ipc = Some(ipc.into());
        self
    }
    /// Set the IPC (Inter-Process Communication) value for this message, using a
    /// type that's got an implementation of [`TryInto`] for `Vec<u8>`. It's best
    /// to define an IPC type within your app, then implement TryFrom/TryInto for
    /// all IPC serialization/deserialization.
    pub fn try_ipc<T>(mut self, ipc: T) -> anyhow::Result<Self>
    where
        T: TryInto<Vec<u8>, Error = anyhow::Error>,
    {
        self.ipc = Some(ipc.try_into()?);
        Ok(self)
    }
    /// Set the metdata field for this request. Metadata is simply a [`String`].
    /// Metadata should usually be used for middleware and other message-passing
    /// situations that require the original IPC and payload to be preserved.
    /// As such, metadata should not always be expected to reach the final destination
    /// of this request unless the full chain of behavior is known / controlled by
    /// the developer.
    pub fn metadata(mut self, metadata: &str) -> Self {
        self.metadata = Some(metadata.to_string());
        self
    }
    /// Set the payload of this request. A [`Payload`] holds bytes and an optional
    /// MIME type.
    ///
    /// The purpose of having a payload field distinct from the IPC field is to enable
    /// performance optimizations in all sorts of situations. Payloads are only brought
    /// across the runtime<>WASM boundary if the process calls `get_payload()`, and this
    /// saves lots of work in data-intensive pipelines.
    ///
    /// Payloads also provide a place for less-structured data, such that an IPC type
    /// can be quickly locked in and upgraded within an app-protocol without breaking
    /// changes, while still allowing freedom to adjust the contents and shape of a
    /// payload. IPC formats should be rigorously defined.
    pub fn payload(mut self, payload: Payload) -> Self {
        self.payload = Some(payload);
        self
    }
    /// Set the payload's MIME type. If a payload has not been set, it will be set here
    /// as an empty vector of bytes. If it has been set, the MIME type will be replaced
    /// or created.
    pub fn payload_mime(mut self, mime: &str) -> Self {
        if self.payload.is_none() {
            self.payload = Some(Payload {
                mime: Some(mime.to_string()),
                bytes: vec![],
            });
            self
        } else {
            self.payload = Some(Payload {
                mime: Some(mime.to_string()),
                bytes: self.payload.unwrap().bytes,
            });
            self
        }
    }
    /// Set the payload's bytes. If a payload has not been set, it will be set here with
    /// no MIME type. If it has been set, the bytes will be replaced with these bytes.
    pub fn payload_bytes<T>(mut self, bytes: T) -> Self
    where
        T: Into<Vec<u8>>,
    {
        if self.payload.is_none() {
            self.payload = Some(Payload {
                mime: None,
                bytes: bytes.into(),
            });
            self
        } else {
            self.payload = Some(Payload {
                mime: self.payload.unwrap().mime,
                bytes: bytes.into(),
            });
            self
        }
    }
    /// Set the payload's bytes with a type that implements `TryInto<Vec<u8>>`
    /// and may or may not successfully be set.
    pub fn try_payload_bytes<T>(mut self, bytes: T) -> anyhow::Result<Self>
    where
        T: TryInto<Vec<u8>, Error = anyhow::Error>,
    {
        if self.payload.is_none() {
            self.payload = Some(Payload {
                mime: None,
                bytes: bytes.try_into()?,
            });
            Ok(self)
        } else {
            self.payload = Some(Payload {
                mime: self.payload.unwrap().mime,
                bytes: bytes.try_into()?,
            });
            Ok(self)
        }
    }
    /// Set the context field of the request. A request's context is just another byte
    /// vector. The developer should create a strategy for serializing and deserializing
    /// contexts.
    ///
    /// Contexts are useful when avoiding "callback hell". When a request is sent, any
    /// response or error (timeout, offline node) will be returned with this context.
    /// This allows you to chain multiple asynchronous requests with their responses
    /// without using complex logic to store information about outstanding requests.
    pub fn context<T>(mut self, context: T) -> Self
    where
        T: Into<Vec<u8>>,
    {
        self.context = Some(context.into());
        self
    }
    /// Attempt to set the context field of the request with a type that implements
    /// `TryInto<Vec<u8>>`. It's best to define a context type within your app,
    /// then implement TryFrom/TryInto for all context serialization/deserialization.
    pub fn try_context<T>(mut self, context: T) -> anyhow::Result<Self>
    where
        T: TryInto<Vec<u8>, Error = anyhow::Error>,
    {
        self.context = Some(context.try_into()?);
        Ok(self)
    }
    /// Attempt to send the request. This will only fail if the `target` or `ipc`
    /// fields have not been set.
    pub fn send(self) -> anyhow::Result<()> {
        if let (Some(target), Some(ipc)) = (self.target, self.ipc) {
            crate::send_request(
                &target,
                &crate::uqbar::process::standard::Request {
                    inherit: self.inherit,
                    expects_response: self.timeout,
                    ipc,
                    metadata: match self.metadata {
                        None => None,
                        Some(str) => Some(str.to_string()),
                    },
                },
                self.context.as_ref(),
                self.payload.as_ref(),
            );
            Ok(())
        } else {
            Err(anyhow::anyhow!("missing fields"))
        }
    }
    /// Attempt to send the request, then await its response or error (timeout, offline node).
    /// This will only fail if the `target` or `ipc` fields have not been set.
    pub fn send_and_await_response(
        self,
        timeout: u64,
    ) -> anyhow::Result<Result<(Address, Message), SendError>> {
        if let (Some(target), Some(ipc)) = (self.target, self.ipc) {
            Ok(crate::send_and_await_response(
                &target,
                &crate::uqbar::process::standard::Request {
                    inherit: self.inherit,
                    expects_response: Some(timeout),
                    ipc,
                    metadata: self.metadata,
                },
                self.payload.as_ref(),
            ))
        } else {
            Err(anyhow::anyhow!("missing fields"))
        }
    }
}

/// Response builder. Use [`ResponseBuilder::new()`] to start a response, then build it,
/// then call [`ResponseBuilder::send()`] on it to fire.
pub struct ResponseBuilder {
    inherit: bool,
    ipc: Option<Vec<u8>>,
    metadata: Option<String>,
    payload: Option<Payload>,
}

#[allow(dead_code)]
impl ResponseBuilder {
    /// Start building a new response. Attempting to send this response will
    /// not succeed until its `ipc` has been set with `ipc()` or `try_ipc()`.
    pub fn new() -> Self {
        ResponseBuilder {
            inherit: false,
            ipc: None,
            metadata: None,
            payload: None,
        }
    }
    /// Set whether this response will "inherit" the payload of the request
    /// that this process most recently received. Unlike with requests, the
    /// inherit field of a response only deals with payload attachment, since
    /// responses don't themselves have to consider responses or contexts.
    ///
    /// *Note that if the payload is set for this response, this flag will not
    /// override it.*
    pub fn inherit(mut self, inherit: bool) -> Self {
        self.inherit = inherit;
        self
    }
    /// Set the IPC (Inter-Process Communication) value for this message. This field
    /// is mandatory. An IPC is simply a vector of bytes. Process developers are
    /// responsible for architecting the serialization/derserialization strategy
    /// for these bytes, but the simplest and most common strategy is just to use
    /// a JSON spec that gets stored in bytes as a UTF-8 string.
    ///
    /// If the serialization strategy is complex, it's best to define it as an impl
    /// of [`TryInto`] on your IPC type, then use `try_ipc()` instead of this.
    pub fn ipc<T>(mut self, ipc: T) -> Self
    where
        T: Into<Vec<u8>>,
    {
        self.ipc = Some(ipc.into());
        self
    }
    /// Set the IPC (Inter-Process Communication) value for this message, using a
    /// type that's got an implementation of [`TryInto`] for `Vec<u8>`. It's best
    /// to define an IPC type within your app, then implement TryFrom/TryInto for
    /// all IPC serialization/deserialization.
    pub fn try_ipc<T>(mut self, ipc: T) -> anyhow::Result<Self>
    where
        T: TryInto<Vec<u8>, Error = anyhow::Error>,
    {
        self.ipc = Some(ipc.try_into()?);
        Ok(self)
    }
    /// Set the metdata field for this response. Metadata is simply a [`String`].
    /// Metadata should usually be used for middleware and other message-passing
    /// situations that require the original IPC and payload to be preserved.
    /// As such, metadata should not always be expected to reach the final destination
    /// of this response unless the full chain of behavior is known / controlled by
    /// the developer.
    pub fn metadata(mut self, metadata: &str) -> Self {
        self.metadata = Some(metadata.to_string());
        self
    }
    /// Set the payload of this response. A [`Payload`] holds bytes and an optional
    /// MIME type.
    ///
    /// The purpose of having a payload field distinct from the IPC field is to enable
    /// performance optimizations in all sorts of situations. Payloads are only brought
    /// across the runtime<>WASM boundary if the process calls `get_payload()`, and this
    /// saves lots of work in data-intensive pipelines.
    ///
    /// Payloads also provide a place for less-structured data, such that an IPC type
    /// can be quickly locked in and upgraded within an app-protocol without breaking
    /// changes, while still allowing freedom to adjust the contents and shape of a
    /// payload. IPC formats should be rigorously defined.
    pub fn payload(mut self, payload: Payload) -> Self {
        self.payload = Some(payload);
        self
    }
    /// Set the payload's MIME type. If a payload has not been set, it will be set here
    /// as an empty vector of bytes. If it has been set, the MIME type will be replaced
    /// or created.
    pub fn payload_mime(mut self, mime: &str) -> Self {
        if self.payload.is_none() {
            self.payload = Some(Payload {
                mime: Some(mime.to_string()),
                bytes: vec![],
            });
            self
        } else {
            self.payload = Some(Payload {
                mime: Some(mime.to_string()),
                bytes: self.payload.unwrap().bytes,
            });
            self
        }
    }
    /// Set the payload's bytes. If a payload has not been set, it will be set here with
    /// no MIME type. If it has been set, the bytes will be replaced with these bytes.
    pub fn payload_bytes<T>(mut self, bytes: T) -> Self
    where
        T: Into<Vec<u8>>,
    {
        if self.payload.is_none() {
            self.payload = Some(Payload {
                mime: None,
                bytes: bytes.into(),
            });
            self
        } else {
            self.payload = Some(Payload {
                mime: self.payload.unwrap().mime,
                bytes: bytes.into(),
            });
            self
        }
    }
    /// Set the payload's bytes with a type that implements `TryInto<Vec<u8>>`
    /// and may or may not successfully be set.
    pub fn try_payload_bytes<T>(mut self, bytes: T) -> anyhow::Result<Self>
    where
        T: TryInto<Vec<u8>, Error = anyhow::Error>,
    {
        if self.payload.is_none() {
            self.payload = Some(Payload {
                mime: None,
                bytes: bytes.try_into()?,
            });
            Ok(self)
        } else {
            self.payload = Some(Payload {
                mime: self.payload.unwrap().mime,
                bytes: bytes.try_into()?,
            });
            Ok(self)
        }
    }
    /// Attempt to send the response. This will only fail if the IPC field of
    /// the response has not yet been set using `ipc()` or `try_ipc()`.
    pub fn send(self) -> anyhow::Result<()> {
        if let Some(ipc) = self.ipc {
            crate::send_response(
                &crate::uqbar::process::standard::Response {
                    inherit: self.inherit,
                    ipc,
                    metadata: self.metadata,
                },
                self.payload.as_ref(),
            );
            Ok(())
        } else {
            Err(anyhow::anyhow!("missing IPC"))
        }
    }
}

/// Create a payload with no MIME type and a generic type, plus a serializer
/// function that turns that type into bytes.
///
/// Example: TODO
pub fn make_payload<T, F>(payload: &T, serializer: F) -> anyhow::Result<Payload>
where
    F: Fn(&T) -> anyhow::Result<Vec<u8>>,
{
    Ok(Payload {
        mime: None,
        bytes: serializer(payload)?,
    })
}

/// Fetch the payload of the most recent message we've received. Returns `None`
/// if that message had no payload. If it does have one, attempt to deserialize
/// it from bytes with the provided function.
///
/// Example:
/// ```
/// get_typed_payload(|bytes| Ok(bincode::deserialize(bytes)?)).unwrap_or(MyType {
///     field: HashMap::new(),
///     field_two: HashSet::new(),
/// });
/// ```
pub fn get_typed_payload<T, F>(deserializer: F) -> Option<T>
where
    F: Fn(&[u8]) -> anyhow::Result<T>,
{
    match crate::get_payload() {
        Some(payload) => match deserializer(&payload.bytes) {
            Ok(thing) => Some(thing),
            Err(_) => None,
        },
        None => None,
    }
}

/// Fetch the persisted state blob associated with this process. This blob is saved
/// using the [`set_state`] function. Returns `None` if this process has no saved state.
/// If it does, attempt to deserialize it from bytes with the provided function.
///
/// Example:
/// ```
/// get_typed_state(|bytes| Ok(bincode::deserialize(bytes)?)).unwrap_or(MyStateType {
///     field: HashMap::new(),
///     field_two: HashSet::new(),
/// });
/// ```
pub fn get_typed_state<T, F>(deserializer: F) -> Option<T>
where
    F: Fn(&[u8]) -> anyhow::Result<T>,
{
    match crate::get_state() {
        Some(bytes) => match deserializer(&bytes) {
            Ok(thing) => Some(thing),
            Err(_) => None,
        },
        None => None,
    }
}

/// Send the capability to message this process to other process(es). This takes an iterator
/// of [`ProcessId`] since capabilities shared this way are only shared locally. To share
/// a capability remotely, first acquire its signed form using [`get_capability`] then
/// attach it to a request/response using [`attach_capability`]. (This will be streamlined
/// in the future!)
///
/// If `our` is not the `Address` of this process, this function will panic, unless you also
/// hold the messaging capability for the given `Address`!
pub fn grant_messaging<I, T>(our: &Address, grant_to: I)
where
    I: IntoIterator<Item = T>,
    T: Into<ProcessId>,
{
    // the kernel will always give us this capability, so this should never ever fail
    let our_messaging_cap = crate::get_capability(our, &"\"messaging\"".into()).unwrap();
    grant_to.into_iter().for_each(|process| {
        crate::share_capability(&process.into(), &our_messaging_cap);
    });
}

/// See if we have the capability to message a certain process.
pub fn can_message(address: &Address) -> bool {
    crate::get_capability(address, &"\"messaging\"".into()).is_some()
}
